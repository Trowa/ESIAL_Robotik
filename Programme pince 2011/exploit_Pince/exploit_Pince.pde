#include <Servo.h> 

Servo verin; // Pin 5
Servo morG;  // Pin 3
Servo morD;  // Pin 6

const int capteurG = 9; // Pin 9
const int capteurD = 10; // Pin 10

const int telemAv01 = A5; // Premier telemetre avant
const int telemAv02 = A3; // Second telemetre avant
const int telemAr = A0; // Telemetre arriere
int inter = 11; // Pin pour interruption vers IA

int ctrlTelemAv01 = 2; // Pin de controle du telemetre Avant 01
int ctrlTelemAv02 = 4; // Pin de controle du telemetre Avant 02
int ctrlTelemAr = 7; // Pin de controle du telemetre Arrière

int etat = 0; // 0 tirette présente - 1 tirette enlevée+avant - 2 tirette enlevée+arriere
int sens = 0;
/*
* On descend la pince au maximum
*/
void pinceBas() {
  if (presencePion() == 0) {  
    verin.writeMicroseconds(1700);
  }
}

/*
* On monte la pince juste au dessus d'un pion
*/
void pinceHaut() {
    verin.writeMicroseconds(1100);
}

/*
* Initialisation : on rentre les mords et on descend la pince au maximum
*/
void start() {
    pinceBas();
    morG.writeMicroseconds(550);
    delay(500);
    morD.writeMicroseconds(2100);
}

/*
* On verifie avec les sharp si un pion est présent dans la pince
* Renvoie 1 si oui, 0 si non
*/
int presencePion() {
    if (digitalRead(capteurG) == LOW || digitalRead(capteurD) == LOW) {
      return 1;
    } else {
      return 0;
    }
}


/*
* Ecarte les mords de la pince dans le bon ordre
*/
void ouverturePince() {
    morD.writeMicroseconds(1100);
    delay(500);
    morG.writeMicroseconds(1900);
}

/*
* Ferme les mords de la pince
* Si un pion est bien présent, on ferme les mords et on renvoie 1, sinon on envoit 'e' à l'IA et on renvoie 0
*/
int fermeturePince() {
    //Si pion present fermer sinon envoyer E (Erreur) et return 0
    if (presencePion() == 1) {
        morD.writeMicroseconds(1600);
        morG.writeMicroseconds(1400);
        delay(500);
        return 1;
    } else {
        Serial.print('e');
        return 0;
    }

}

/*
* Pour lever un pion on tente de ferme la pince et si ça réussit on lève et on envoie 'k' pour confirmer l'action
*/
void leverPion() {
    if (fermeturePince() == 1) {
        pinceHaut();
        Serial.print('k');
    }
}

/*
* Pour larguer un pion on vérifie la présence d'un pion sous celui à larguer, on ouvre et on descend la pince
* Si l'opération est une réussite, on envoie 'k', sinon 'e'
*/
void posePion() {
    //Si pion Present ouverturePince et envoyer K sinon envoyer E
    if (presencePion() == 1) {
        ouverturePince();
        delay(500);
        pinceBas();
        delay(1000); //to DO à Regler
        Serial.print('k');

    } else {
        Serial.print('e');
    }
}

/*
* Verifie la presence de l'adversaire
*/
void presenceAdversaire() {
    while (1) {
      int adv = 0;
      digitalWrite(ctrlTelemAv01, HIGH);
      delayMicroseconds(20);
      digitalWrite(ctrlTelemAv01, LOW);
      delay(100);
      int t1 = analogRead(telemAv01);
      if (t1 < 50) {
        adv = 1;
      }
      
      digitalWrite(ctrlTelemAv02, HIGH);
      delayMicroseconds(20);
      digitalWrite(ctrlTelemAv02, LOW);
      delay(100);
      int t2 = analogRead(telemAv02);
      if (t2 < 50) {
        adv = 1;
      }
      /*
      digitalWrite(ctrlTelemAr, HIGH);
      delayMicroseconds(20);
      digitalWrite(ctrlTelemAr, LOW);
      delay(100);
      int t3 = analogRead(telemAr);
      if (t3 < 25) {
        adv = 1;
      }*/
      
      if (adv == 0) {
        digitalWrite(inter, LOW);
        //Serial.println("low");
      } else {
        digitalWrite(inter, HIGH);
        //Serial.println("high");
      }
    }
}

/*
* On ecoute les ordres de l'IA
*/
void ecouterSerie() {
    char c = 'x';
    if (Serial.available() > 0) {
      c = Serial.read();
    }
    switch (c) {
        case 'g': //Si G (go, tirette enlevee) etat = 1 + ouverturePince()
            etat = 1;
            ouverturePince();
            break;
        case 'a': //Si A (Avance) etat = 1
            etat = 1;
            sens = 1;
            break;
        case 'r': //Si R (recule) etat = 2
            etat = 2;
            sens = 0;
            break;
        case 'l': //Si L (leverPion) leverPion()
            leverPion();
            break;
        case 's': //Si S (Serre) fermeturepince
            if (fermeturePince() == 1) {
                Serial.print('k');
            } else {
                Serial.print('e');
            }
            break;
        case 'd': //Si D (Desserre) Ouveturepince
            ouverturePince();
            delay(500);
            Serial.print('k');
            break;
        case 'p': //Si P (posePion) posePion()
            posePion();
            break;
        case 'e': //Si E (ennemi) on indique si l'adversaire est toujours la
            presenceAdversaire();
            break;
        case 'b' :
            pinceBas();
            break;
        case 'c' : //Presence Pion
            if (presencePion()==1) {
              Serial.print('k');
            } else {
              Serial.print('e');
            }
    }
}

void verifierTelemetresAvants() {
    //si detection, interruption vers IA
    digitalWrite(ctrlTelemAv01, HIGH);
    delayMicroseconds(20);
    digitalWrite(ctrlTelemAv01, LOW);
    delay(100);
    if (analogRead(telemAv01) < 40) {
      digitalWrite(inter, HIGH);
      etat = 3;
    }
    
    digitalWrite(ctrlTelemAv02, HIGH);
    delayMicroseconds(20);
    digitalWrite(ctrlTelemAv02, LOW);
    delay(100);
    if (analogRead(telemAv02) < 40) {
      digitalWrite(inter, HIGH);
      etat = 3;
    }
}

void verifierTelemetresArrieres() {
    //si detection, interruption vers IA
    digitalWrite(ctrlTelemAr, HIGH);
    delayMicroseconds(20);
    digitalWrite(ctrlTelemAr, LOW);
    delay(100);
    if (analogRead(telemAr) < 25) {
      digitalWrite(inter, HIGH);
      etat = 3;
    }
}

void setup() {
    // On demarre la liaison serie
    Serial.begin(115200);
    
    // On initialise les servos et le verin
    verin.attach(5);
    morG.attach(3);
    morD.attach(6);
    
    // On regle les pins des sharps
    pinMode(capteurG, INPUT);
    pinMode(capteurD, INPUT);
    digitalWrite(capteurG, HIGH);
    digitalWrite(capteurD, HIGH);
    
    // On regle les pins de controles des telemetres US
    pinMode(ctrlTelemAv01, OUTPUT);
    pinMode(ctrlTelemAv02, OUTPUT);
    pinMode(ctrlTelemAr, OUTPUT);
    pinMode(13, OUTPUT);
    digitalWrite(ctrlTelemAv01, LOW);
    digitalWrite(ctrlTelemAv02, LOW);
    digitalWrite(ctrlTelemAr, LOW);
    digitalWrite(13, LOW);
    
    // On regle la pin d'interruption
    pinMode(inter, OUTPUT);
    digitalWrite(inter, LOW);
    
    // On met la pince en position initiale
    start();
    pinceHaut();
}

void loop() {
    switch (etat) {
        case 0: // allumage tirette presente
            ecouterSerie();
            break;
        case 1: //Robot en fonctionnement tirette enlevée, marche avant
            verifierTelemetresAvants();
            ecouterSerie();
            break;

        /*case 2: //Robot en fonctionnement tirette enlevée, marche arriere
            verifierTelemetresArrieres();
            ecouterSerie();
            break;
        case 3: //Si un adversaire est detecte, on previens l'IA s'il n'est plus la
            presenceAdversaire();
            break;*/
    }
    presenceAdversaire();
}
